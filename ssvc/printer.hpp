/*
 * Copyright (C) 2013 midnightBITS
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef __PRINTER_HPP__
#define __PRINTER_HPP__

#include <ssdp.hpp>
#include <boost/filesystem.hpp>
#include <iostream>
#include <service_description.hpp>

namespace fs = boost::filesystem;
using namespace net::ssdp;

struct printer
{
	const service_description& descr;
	fs::path out;
	fs::path proxy;
	fs::path impl;
	std::string safe_name;
	std::string class_name;
	std::string class_type;
	std::string class_id;

	struct header
	{
		fs::ofstream o;
		std::string guard;

		header(const fs::path& name)
			: o(name)
			, guard("__" + name.filename().string() + "__")
		{
			for (auto&& c : guard)
			{
				if (std::isalnum((unsigned char) c))
					c = (char) std::toupper((unsigned char) c);
				else
					c = '_';
			}

			o <<
				"// This file is autogenerated.\n"
				"// Do not edit.\n"
				"\n"
				"#ifndef " << guard << "\n"
				"#define " << guard << "\n\n";
		}

		~header()
		{
			o << "\n\n#endif // " << guard << "\n";
		}

		template <typename T>
		header& operator << (const T& rhs)
		{
			o << rhs;
			return *this;
		}
	};

	printer(const service_description& descr, const fs::path& out, const std::string& class_name, const std::string& class_type, const std::string& class_id)
		: descr(descr)
		, out(out)
		, proxy(out.parent_path() / (out.stem().string() + ".ipp"))
		, impl(out.parent_path() / (out.stem().string() + "_example.cpp"))
		, safe_name(out.stem().string())
		, class_name(class_name)
		, class_type(class_type)
		, class_id(class_id)
	{
		for (auto&& c : safe_name)
		{
			if (std::isalnum((unsigned char) c))
				c = (char) std::tolower((unsigned char) c);
			else
				c = '_';
		}
	}

	void define_enum(header& o, const state_variable& var)
	{
		if (var.m_type != "string")
			std::cerr << "Warning: enum is not a string! (" << var.m_type << ")\n";

		auto type = var.getType();
		o << "\n"
			"	enum " << type << " {\n"
			"		" << type << "_UNKNOWN,";

		for (auto && val : var.m_values)
			o << 
			"\n"
			"		VALUE_" << val << ",";

		o <<
			"\n"
			"	};\n";
	}

	template <typename C, typename F>
	std::vector<std::string> generate(C& coll, F handler)
	{
		std::vector<std::string> out;
		out.reserve(coll.size());

		for (auto&& arg: coll)
			out.push_back(handler(arg));

		return out;
	}

	void print_func(std::ostream& o, std::string pre, const std::vector<std::string>& args, size_t width = 78)
	{
		o << pre << "(";

		size_t len = 1;
		for (auto && c : pre)
		{
			if (c != '\t') { len += 1; c = ' '; }
			else           { len += 4; }
		}

		size_t line = len;
		bool first = true;
		for (auto && arg : args)
		{
			if (first) first = false;
			else
			{
				o << ",";
				if (line > len && line > width)
				{
					o << "\n" << pre;
					line = len;
				}
				o << " ";
			}


			line += arg.length() + 1;
			o << arg;
		}

		o << ")";
	}

	void print_func(header& o, std::string pre, const std::vector<std::string>& args, size_t width = 78)
	{
		print_func(o.o, pre, args, width);
	}

	void print_interface(header& o)
	{
		o <<
			"\n"
			"	struct I" << class_name << ": ServiceInterface\n"
			"	{\n"
			"		const char* get_type() const override { return \"" << class_type << "\"; }\n"
			"		const char* get_id() const override { return \"" << class_id << "\"; }";

		for (auto && action : descr.m_actions)
		{
			auto args = generate(action.m_args, [&](const action_arg& arg) { return arg.getCType(descr.m_variables, arg.m_input) + " " + arg.m_name; });
			args.insert(args.begin(), "const http::http_request& http_request");
			args.insert(args.begin(), "const client_info_ptr& client");

			o <<
				"\n\n";
			print_func(o, 
				"		virtual error_code " + action.m_name, args); o << " = 0;";
		}

		o <<
			"\n"
			"	};\n"
			"\n";

	}

	void print_type_info(header& o)
	{
		o <<
			"namespace net { namespace ssdp { namespace import {\n";

		for (auto && var : descr.m_variables)
		{
			if (var.m_values.empty())
				continue;

			auto type = safe_name + "::" + var.getType();
			o << 
				"\n"
				"\n"
				"	template <>\n"
				"	struct type_info<" << type << "> {\n"
				"		static " << type << " unknown_value() { return " << type << "_UNKNOWN; }\n"
				"\n"
				"		static std::string to_string(" << type << " rhs)\n"
				"		{\n"
				"			switch(rhs)\n"
				"			{";

			for (auto && val : var.m_values)
				o <<
				"\n"
				"			case " << safe_name << "::VALUE_" << val << ": return \"" << val << "\";";

			o <<
				"\n"
				"			};\n"
				"\n"
				"			return \"" << var.getType() << "(\" + std::to_string(rhs) + \")\";\n"
				"		};\n"
				"\n"
				"		static " << type << " from_string(const std::string& rhs)\n"
				"		{";

			for (auto && val : var.m_values)
				o <<
				"\n"
				"			if (rhs == \"" << val << "\") return " << safe_name << "::VALUE_" << val << ";";

			o << 
				"\n"
				"\n"
				"			return " << type << "_UNKNOWN;\n"
				"		};\n"
				"\n"
				"		static void get_config(std::ostream& o)\n"
				"		{\n"
				"			o <<\n"
				"				\"			<dataType>string</dataType>\\n\"\n"
				"				\"			<allowedValueList>\\n\"\n";
			for (auto && val : var.m_values)
				o <<
				"				\"				<allowedValue>" << val << "</allowedValue>\\n\"\n";
			o <<
				"				\"			</allowedValueList>\\n\";\n"
				"		}\n"
				"	};\n";

		}

		o << "}}} // net::ssdp::import\n";
	}

	void print_action_proxy(header& o, const action& action)
	{
		o <<
			"		struct Raw" << action.m_name << "\n"
			"		{\n"
			"			struct request\n"
			"			{\n";

		for (auto&& arg : action.m_args)
		{
			if (!arg.m_input)
				continue;
			o <<
				"				" << arg.getCType(descr.m_variables) << " " << arg.m_name << ";\n";
		}

		o <<
			"			};\n"
			"\n"
			"			struct response\n"
			"			{\n";

		for (auto&& arg : action.m_args)
		{
			if (arg.m_input)
				continue;
			o <<
				"				" << arg.getCType(descr.m_variables) << " " << arg.m_name << ";\n";
		}

		o <<
			"			};\n"
			"		};\n"
			"\n";

	}

	void print_proxy(header& o, const action& action)
	{
		std::vector<std::string> call;
		int ins = 0;
		int outs = 0;
		for (auto && arg : action.m_args)
			(arg.m_input ? ins : outs)++;

		call.emplace_back("const client_info_ptr& client");
		call.emplace_back("const http::http_request& http_request");
		if (ins > 0)
			call.emplace_back("const Raw" + action.m_name + "::request& request");
		else
			call.emplace_back("const Raw" + action.m_name + "::request& /*request*/");
		if (outs > 0)
			call.emplace_back("Raw" + action.m_name + "::response& response");
		else
			call.emplace_back("Raw" + action.m_name + "::response& /*response*/");

		auto args = generate(action.m_args, [&](const action_arg& arg) { return (arg.m_input ? "request." : "response.") + arg.m_name; });
		args.insert(args.begin(), "http_request");
		args.insert(args.begin(), "client");

		o <<
			"\n";
		print_func(o,
			"		error_code raw_" + action.m_name, call);
		o << 
			"\n"
			"		{\n";
		print_func(o,
			"			return " + action.m_name, args); o << ";\n"
			"		};\n";
	}

	void print_proxy(header& o)
	{
		size_t name_len = 0, ref_len = 0;

		for (auto && action : descr.m_actions)
		{
			for (auto && arg : action.m_args)
			{
				auto len = arg.m_name.length();
				if (!arg.m_input) len++; //'output' is one char longer than 'input'
				if (len > name_len)
					name_len = len;

				len = arg.m_type_ref.length();
				if (len > ref_len)
					ref_len = len;
			}

		}

		o <<
			"\n"
			"namespace net { namespace ssdp { namespace import { namespace " << safe_name << " {\n"
			"\n"
			"	struct " << class_name << "ServerProxy: ServerImpl<" << class_name << "ServerProxy, I" << class_name << ", " << descr.m_version.m_major << ", " << descr.m_version.m_minor << ">\n"
			"	{\n";

		for (auto && action : descr.m_actions)
			print_action_proxy(o, action);

		o <<
			"		" << class_name << "ServerProxy()\n"
			"		{";

		for (auto && var : descr.m_variables)
		{
			o <<
				"\n"
				"			auto& var_" << var.m_name;

			auto len = ref_len - var.m_name.length();
			for (size_t i = 0; i < len; ++i) o.o.put(' ');

			o << " = add_" << (var.m_event ? "event" : "type") << "<" << var.getCType() << ">(\"" << var.m_name << "\");";
		}
		for (auto && var : descr.m_variables)
		{
			if (var.m_referenced)
				continue;

			o <<
				"\n"
				"			ignore(var_" << var.m_name << ");";
		}

		if (!descr.m_variables.empty() && !descr.m_actions.empty())
			o << "\n";

		for (auto && action : descr.m_actions)
		{
			o << 
				"\n"
				"			add_method(\"" << action.m_name << "\", &" << class_name << "ServerProxy::raw_" << action.m_name << ")";
			for (auto && arg : action.m_args)
			{
				o <<
					"\n"
					"				." << (arg.m_input ? "input" : "output") << "(\"" << arg.m_name << "\",";

				auto len = arg.m_name.length();
				if (!arg.m_input) len++; //'output' is one char longer than 'input'

				len = name_len - len;
				for (size_t i = 0; i < len; ++i) o.o.put(' ');

				o << " var_" << arg.m_type_ref << ",";

				len = ref_len - arg.m_type_ref.length();
				for (size_t i = 0; i < len; ++i) o.o.put(' ');

				o << " &Raw" << action.m_name << "::" << (arg.m_input ? "request" : "response") << "::" << arg.m_name << ")";
			}
			o << ";\n";
		}

		o <<
			"\n"
			"		}\n";

		for (auto && action : descr.m_actions)
		{
			print_proxy(o, action);
		}

		o <<
			"	};\n"
			"\n"
			"}}}} // net::ssdp::import::" << safe_name;
	}

	void print_impl_header(std::ostream& o)
	{
		o <<
			"#include <string>\n"
			"#include <service_impl.hpp>\n"
			"#include \"" << out.filename().string() << "\"\n"
			"\n"
			"namespace net { namespace ssdp { namespace import { namespace " << safe_name << " {\n";
		o <<
			"\n"
			"	struct " << class_name << ": " << class_name << "ServerProxy\n"
			"	{";

		for (auto&& action : descr.m_actions)
		{
			auto args = generate(action.m_args, [&](const action_arg& arg) { return arg.getCType(descr.m_variables, arg.m_input) + " " + arg.m_name; });
			args.insert(args.begin(), "const http::http_request& http_request");
			args.insert(args.begin(), "const client_info_ptr& client");

			o <<
				"\n";
			print_func(o,
				"		error_code " + action.m_name, args); o << " override;\n";
		}

		o <<
			"	};\n"
			"\n"
			"}}}} // net::ssdp::import::" << safe_name << "\n"
			"\n";
	}

	void print_impl_code(std::ostream& o)
	{
		o <<
			"\n"
			"namespace net { namespace ssdp { namespace import { namespace " << safe_name << " {\n";

		for (auto && action : descr.m_actions)
		{
			auto args = generate(action.m_args, [&](const action_arg& arg) { return (arg.m_input ? "/* IN  */ " : "/* OUT */ ") + arg.getCType(descr.m_variables, arg.m_input) + " /*" + arg.m_name + "*/"; });
			args.insert(args.begin(), "const http::http_request& /*http_request*/");
			args.insert(args.begin(), "const client_info_ptr& /*client*/");

			o <<
				"\n"; print_func(o,
				"	error_code " + class_name + "::" + action.m_name, args, 0); o << "\n"
				"	{\n"
				"		return error::not_implemented;\n"
				"	}\n";
		}

		o <<
			"\n"
			"}}}} // net::ssdp::import::" << safe_name << "\n"
			"\n";
	}

	void print_interface()
	{
		header o(out);

		o <<
			"#include <string>\n"
			"#include <service_impl.hpp>\n"
			"\n"
			"namespace net { namespace ssdp { namespace import { namespace " << safe_name << " {\n";

		for (auto&& var : descr.m_variables)
		{
			if (var.m_values.empty())
				continue;
			define_enum(o, var);
		}

		o << "\n";

		print_interface(o);

		o <<
			"}}}} // net::ssdp::import::" << safe_name << "\n"
			"\n"
			"#include \"" << proxy.filename().string() << "\"";
	}

	void print_proxy()
	{
		header o(proxy);
		print_type_info(o);
		print_proxy(o);
	}

	void print_implementation()
	{
		fs::ofstream o(impl);

		auto guard = "__" + class_name + "_EXAMPLE__";
		for (auto && c : guard)
		{
			if (std::isalnum((unsigned char) c))
				c = (char) std::toupper((unsigned char) c);
			else
				c = '_';
		}

		o <<
			"// This is just an example to jump start server creation.\n"
			"// Copy and continue.\n"
			"\n"
			"// ---------- HEADER ----------\n"
			"#ifndef " << guard << "\n"
			"#define " << guard << "\n"
			"\n";

		print_impl_header(o);

		o <<
			"\n"
			"\n"
			"#endif // " << guard << "\n"
			"\n"
			"// ---------- CODE ----------\n";

		print_impl_code(o);
	}

private:
	printer(const printer&);
	printer& operator=(const printer&);
};

#endif // __PRINTER_HPP__